> 在使用缓存的过程中，我们会遇到各种各样的问题，要了解问题，避免问题，不行再解决问题

### 缓存穿透

缓存穿透的本质
	我们的缓存模式，是会在查不到缓存数据的时候，去查 db，然后把 db 的数据写入缓存里面，这个查询 db 这一步就可能被人利用给我们造成危害
	由于查不到就去查 DB，所以如果有大批量的查询全部来查询这个不存在的 key，那就相当于没有缓存，所有的请求都是去 db 查询的，流量够大就会导致 db 挂掉

解决方案
	1. 我们的数据可能有 id 或者其他的一些用户信息，用于判断，比如我们可以直接拦截所有 id 小于 0 的请求（id 为-1 的很可能就是攻击者）
	2. 如果发生了在缓存里面没有取到的数据并且在数据库里面也没有取到，那我们可以通过设置 key-value 为 key-null 来防止用户反复攻击同一个 key，但是设置过期时间不能太长，30 s 差不多
	3. 可以考虑使用[[#布隆过滤器]] 

#### 布隆过滤器



是什么？
	Loomfilter 就类似于一个 hashset，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断某个 key 是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于 hash 算法和容器大小，是一种巧妙的概率模型，可以用来判断一个东西 `一定不存在或者可能存在`

原理：
	当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。

详解:
	简单来说，我们存储数据是二进制的，数据不是 0 就是 1，默认是 0，那我们就用 0 表示数据不村在，1 表示数据存在，而布隆过滤器本身，就是一个很长的二进制和一些列随机映射函数，当有数据进入的时候，就会经历下面的流程
	1. 通过 k 个哈希函数计算，返回 k 个哈希值
	2. 将 k 个哈希值对应映射到 k 个二进制数组下标
	3. 然后把 K 个下标对应的二进制数据变成 1
	也就是说，存进来的数据布隆过滤器先放好，然后再来数据的话，我先检查下我 K 个 hash 算法能不能找到对应的节点，并且其中的二进制数据是不是 1，如果有 0 存在那就说明数据不存在了

优缺点
	优点在于，他用的二进制，那么空间消耗都会特别小，缺点就是存在误判，只能判断可能存在，而且不好删除，hash 存在 hash 冲突，很可能多个合成了一个

  
### 缓存击穿

是什么？
	数据中可能存在缓存中**没有**但是数据库中**有**的数据（缓存数据到期可能会出现这个情况），这时候一般情况下，我们都会去数据库查询，但是这个时候，如果用户并发量很大，大量的请求同时去读取数据库，也会导致数据库挂掉，简单来说，就是热点数据失效的一瞬间，还没来得及重新产生，就有海量数据直达数据库

解决方案
	1. 首先就是热点数据可以续期，持续的访问可以让数据不断的续期，避免因为过期导致击穿
	2. 缓存失效，重建缓存加互斥锁，加锁保护数据库，当线程发现缓存不存在的时候，就会尝试加锁，只有加到锁的线程可以去查询数据库，然后重建缓存，避免高流量


### 缓存雪崩

是什么？
	指的是大量的应用请求因为异常，无法在 Redis 缓存中进行处理，就会像雪崩一样，直接打到数据库


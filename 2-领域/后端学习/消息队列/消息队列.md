---
created: 2024-05-24
updated: 2024-05-24
Type: knowledge
Status: ⌛️ 等待
tags:
---
## 为什么需要消息队列？

1. 异步处理
2. 服务解耦
3. 流量控制

消息队列在处理分布式场景有着比较大的作用，但是**单体工程**引入可能出现消息延迟，消息不同步等问题，看情况引入，合适的场景最好用


## 消息队列中的概念

### 主题和队列

队列如其名，单独的端对端的一个队列，直直的前端对后端

![[主题和队列extra|652]]

### 消息模型

#### RabbitMQ

- ~ RabbitMQ  采用的是现在市面上很少用到的队列模型，![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240604225653.png) 但是他中间有个 exchange 的交换机，让我想起了 gateway 中的 exchange ，通过 exchange 配置，把不同的消息队列中的消息转发给对应的消费者

#### RocketMQ

RocketMQ RocketMQ 采用的是标准的订阅发布模型，即上图所示的主题订阅模式，但是并不意味着 RocketMQ 没有队列的概念，相反，**队列**在 RocketMQ 中是一个非常重要的概念几乎所有的消息队列产品都使用一种非常朴素的“**请求 - 确认**”机制，确保消息不会在传递过程中由于网络或服务器故障丢失。具体的做法也非常简单。在生产端，==生产者先将消息发送给服务端，也就是 Broker==，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应，如果生产者没有收到服务端的确认或者收到失败的响应，则会**重新发送消息**；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端**发送消费成功的确认**，服务端**只有收到消费确认后，才认为一条消息被成功消费**，否则它会给消费者**重新发送这条消息**，直到收到对应的消费成功确认。
这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。

也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。

**每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费**。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。

RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。

消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。

在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的

![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240604231044.png)

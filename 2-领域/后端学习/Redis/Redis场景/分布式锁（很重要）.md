---
Created: 2024-01-17
Updated: 2024-01-21
Type: knowledge
Status: 🌱 活跃
截止日期: 
目标: 
领域: 
tags:
---
### 分布式锁是什么

首先，锁可以理解为针对某项资源使用权限的管理，通常用来控制共享资源, 而分布式锁，顾名思义，是在分布式环境下的锁，用来管理多台不同机器上的线程，竞争同一项资源

### 分布式锁应该具备哪些特性？

^34901e

1. 互斥性
	锁的目的是保证同一时刻只有一个线程持有锁，所以要保证互斥
2. 安全性
	需要避免锁因为异常的出现而永远不被释放，需要有兜底的释放锁的能力，并保证后续其他竞争者也能加锁
3. 对称性
	同一个锁，加锁解锁的必须是同一个对象，不能解锁别人的锁
4. 可靠性
	需要能处理一定程度的异常，而且要有容灾的能力

### 分布式锁常用实现方式
#### 最简化版本

最简化版本就是直接使用 Redis 的 setnx 命令，这个命令如果 key 存在，那么会返回 0，不会影响该数据
```bash
setnx key value
```
基于这个特性，我们就可以利用这个方式加锁解锁了
##### 互斥性 ：具体实现如下：
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111221311.png)
通过 setnx 进行锁的操作

但是这么做==解决了互斥性==的问题，但是==安全性和可靠性还有对称性该怎么解决==？[[#分布式锁应该具备哪些特性？]]
##### 安全性
==安全性==当然是支持过期时间了，这样可以保证一旦一个线程持有锁时间太长，就会自动解锁，保证服务能继续进行下去，但是这时候又引入了一个新的问题，怎么加过期时间，虽然 Redis 提供了 setNx 方法 [[RedisString的编码以及操作#^244caf|set的一些操作]]，但是 setnx 和 expire 不具备原子性，也就是说，如果是 `setnx key value` 然后再 `expire key 100` 这种操作可能在中间（服务器宕机）就断掉了，所以 Redis 官方也提供了原子性的写法 `set key value nx ex seconds `
```bash
set key value nx ex seconds 
```
另外还有就是 **watchDog 的机制**，通过监听锁和业务的流程来给锁续期，保证业务流程不会在活没干完的时候，锁就过期了, 这个可以根据业务判断是否加上，（关于同样是做分布式锁的 zookeeper 有心跳监听的能力，在这个上面就更进一步了）
- [ ] zookeeper 的创建分布式锁过程有时间就需要补充
- [ ] etcd 的分布式锁怎么操作，什么流程
- [ ] watchDog 的机制是什么机制--时间轮
- [ ] 锁的可重入性、读写锁、公平锁
- [ ] 以及一个 singleFight 了解一下
##### 对称性
上面的解决了安全性的问题，保证了一个锁不会被长时间占有，但是还存在一个重要问题，这个锁可能会被别的进程解锁
	**例如**：由于业务流程比较长，或者网络延迟 GC 卡顿等原因，导致锁过期，而业务还会继续进行。这时候，业务 B 已经拿到了锁，准备去执行，这个时候服务 A 恢复过来并做完了业务，就会释放锁，而 B 却还在继续执行。那就是说，A 把 B 的锁强行释放掉了
所以我们需要进一步的解决方案，那就是设置 ownerId ，即每个人只能释放自己的锁，==遵循谁申请谁释放==，这里注解一下，**key 还是那个 lock 的 key，但是 value 变成了判断依据**，申请后还要判断里面的数据是不是自己的，否则不能解锁
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111230557.png)
这样，每次获取锁的删除锁的操作，都检查锁的名称对不对，不然不删除，**这就解决了对称性的问题，但是实际上并不完善**
因为很明显，你看删除锁的流程，获取锁->返回值->删除锁，这三步不是原子操作，那么在分布式的环境下就有一个大问题，你获取的时候，锁是你自己的，但是你删除锁的时候，其实是其他人的锁，因为这些操作不具有原子性，所以我们就引入了 Redis 的特性 [LUA](https://www.runoob.com/lua/lua-tutorial.html), **使用 LUA 脚本，我们可以获得原子性的操作的能力**
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111231447.png)
- [x] Reids 分布式锁还没写完，未完待续 ✅ 2024-01-12
##### 可靠性
1. 那么上面的其实就解决了三个重要特性，互斥性，安全性，对称性，还有最后一个，可靠性，也就是说，需要解决的是，针对一些异常场景，网络波动、服务器挂掉、业务执行时间过长，要怎么解决, 一般来说，有两种大的解决办法
	1. [[#主从容灾]] 
	2. [[#多机部署]] 

下面简单介绍一下
##### 主从容灾
更详细的另一篇笔记有提到 [[多机部署#主从模式]]
主从容灾就是最简单的方式，即为 Redis 配置从节点，从节点挂了就用主节点顶上去，Redis 有了成熟的解决方式，就是**哨兵模式**
	1. 哨兵模式就是说，哨兵总事以固定的频率去发现节点、故障检测，然后在检测到主节点故障时以安全的方式执行故障转移，确保集群的高可用性
	2. 一般情况下，哨兵节点每隔 10 秒（故障转移时每隔 1 秒）向主从节点发送 `INFO` 命令，以此获取主从节点的信息。第一次执行时，哨兵仅知道我们给出的主节点信息，通过对主节点执行 `INFO` 命令就可以获取其从节点列表。如此周期性执行，就可以不断发现新加入的节点
	3. 因为哨兵模式有同步的延迟，很可能使得数据丢失，也可能导致分布式锁失效
	4. 具体的可以看这篇   [[多机部署#主从的进阶！哨兵模式]]
- [x] 可以到时候再把哨兵模式的流程整理成一个文档 ✅ 2024-01-15
##### 多机部署
相对于哨兵模式，多级部署是更可靠的方法，多机部署对一致性的实现更高一点，比如 Redis 的 RedLock 算法，大概的思路就是多个机器，通常是奇数个，**达到一半以上同意加锁才算加锁成功**，这里是有原因的，由于主从的操作是异步的，也就是说，当客户端请求加锁的时候（`set key`），主服务会


流程
	1. 首先是假设有五个 Redis 主节点，基本保证不会同时宕机
	2. 客户端会同时向五个 Redis 申请锁，只要超过一半的 Redis 返回成功，就说明获取到了锁，超过一半的 Redis ==失败==则要发送解锁命令（==没申请到就自己把锁解除了，防止锁卡在手上==），失败的原因可能有很多，比如网络问题，或者有个 Redis 干脆就宕机了，但是只要超过一半的 Redis 节点成功的返回了数据，那就表示获取锁成功，线程就能继续
	3. 有一点需要注意的是，由于要向多个 Redis 发送消息，所以锁剩余时间要减去请求时间，如果剩余时间为 0，那么也是获取锁失败，比如你拿过来一个锁的时候，Redis 返回给你的时间是 30 s, 但是你请求时间花了一秒，所以到手的时候锁实际剩余剩余时间是 29 s, 这个时间为 0 说明锁过期了，或者网络问题导致你申请卡在手上，那么就属于获取锁失败，走失败的逻辑，也就是解锁，重新请求或者就不请求了，看业务实际情况
	4. 使用完成之后，需要同时向五个 Redis 发送解锁请求 ^edb40e


##### 可靠性深究
有了 Redlock 就一定能保证分布式锁的可靠性嘛？
	结论是不行，分布式系统的三大困境，简称（NPC），所以没有完全可靠的分布式锁

NPC 是什么？
	1. N: networkDelay（网络延迟）当分布式锁获得返回包时间过长，就是上面提到的一个问题  [[#^edb40e|看第三点]] Redlock 我们有解决方案是减去了请求时间的，一定程度上是可以解决这个问题
	2. P: Process Pause （进程暂停）比如发生了 GC，获取锁的线程开始处理流程，但是处于 GC 执行中，导致锁超时（超时后其他的线程就可以拿到锁了，但是这个时候，**线程并不知道自己的锁过期了，因为他处于 GC 流程之前是有剩余时间的**），这样会导致一个问题就是等 GC 结束，会有两个线程拿到同一个分布式锁 lock（尽管里面的 value 不一样了），然后他们就会都走完业务流程，见下图 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240114192725.png) 分布式锁就失效了
	3. C: Clock Drift（时钟漂移）可以理解成不同机器里面的时间不一致，导致锁瞬间过期或者其他情况 [分布式系统：与时间有关的故事 - 知乎](https://zhuanlan.zhihu.com/p/183843997)，也会导致上面的情况，让 A 和 B 线程拥有相同的锁，同时执行业务流程，破坏了互斥性


### 总结

1. 四大特性：互斥性、安全性、对称性、可靠性 [[#^34901e|四大特性]]
2. 可靠性可以两个方面来看，一个集群一个多机部署
3. 分布式锁没有绝对可靠的
#    计算机网络学习

#计算机网络 
### 计算机网络体系结构

#### OSI体系结构（7层）

在Osi这个标准模型中，每个分层都接受由他下一层所提供的特定服务，并负责为自己的上一层提供特定的服务

​	上下层之间的交互所遵循的约定叫叫==接口==，同一层次之间的交互遵循的约定就叫做==协议==



	- 物理层
	- 数据链路层
	- 网络层
	- 运输层
	- 会话层
	- 表示层
	- 应用层

![image-20231205002700022](D:\study\img\image-20231205002700022.png)

###### 为什么分层以及分层的目的是什么？

![image-20231205003935780](D:\study\img\image-20231205003935780.png)





#### 发送流程

1. 应用层 ：构建一个HTTP请求报文传给运输层

2. 运输层：运输层给报文添加一个TCP首部，使之成为TCP报文段，

   > 该首部的作用是区分应用进程以及实现可靠传输

3. 网络层:给报文段添加一个IP首部，使之成为IP数据报

   > ​	作用是使得IP数据报可以在网络上传输，也就是被路由器转发

4. 数据链路层：给IP数据报添加一个首部和一个尾部（ETH）使之成为帧

   > 首部的目的是为了能让帧在网络传输的时候可以被相应的主机接收
   >
   > 尾部的目的是为了让收到的目的主机检测收到的帧是否有误码

5. 物理层：将帧视为比特流，还会给比特流前面添加前导码，然后转化成相应的信号发送给传输媒体

   > 前导码的作用是为了让目的主机做好接收帧的准备

#### 接收流程

 同发送流程差不多，反过来拆分就是，就是层层封装和层层解码的区别

#### 专用术语

- 实体
- 协议
- 服务

##### 实体

​	**实体是指任何可以发送或者接收信息的硬件或软件进程**

- 对等实体：收发双方相同层次中的实体，（我理解就是分层，我传输有五层，层层包装，你接受有五层层层解码，那么对应的五层结构中就一一对应为对等实体，我的应用对你的应用等）



##### 协议

​	**是指控制两个对等实体进行逻辑通信的规则的集合，如应用层在应用层协议的规则下（HTTP,SMTP等）进行通信**

##### 服务

**指每一层结构都会享受封装层提供的服务，就比如我链路层给你加完了前后部，我需要物理层提供转成比特流并发送的服务**

下层使用上层的服务需要通过与下层交换一些命令，称之为服务原语

- 服务访问点：例如数据链路层的服务访问点为“帧”的类型字段

![image-20231205010923418](D:\study\img\image-20231205010923418.png)

### 几个问题

#### 为什么要设计分层网络模型

1. 首先设计这个模型的原因就是如果各家的网络模型都不一样的话，就会导致大家只能用同一个产品，无法产品间的相互通信
2. 其次，分层的作用是方便更改和替换层间不同的协议，比如以打电话为例，底层传输是汉语交流，下层协议是电话，那么完全可以替换成无线电的新底层，变成用无线电对话

#### 两个模型各有多少层

1. OSI模型有7层，但是只是一个标准模型，实际上linux里面的模型是TCP/IP的四层
2. TCP/IP有四层

#### 模型中每一层的作用

1. 首先是OSI的七层结构（大致自己理解是这样的）
   1. 最上级是**应用层**：应用顾名思义，他的协议就是用来处理不同应用间的通信的，qq对qq，微信对微信
   2. 第二级是**表示层**，这里会对应用层的请求加上首部和尾部（每一层基本都是差不多这样，下面不多赘述），是负责把请求转换成标准的格式，相当于标准化
   3. 然后是**会话层**，负责建立会话--》建立通信和断开通信，
   4. 然后是传输层：可靠传输，我理解就是和目标主机对接的时候，==告诉他这个数据是发送给你的？？==，然后目标主机会检测首部和尾部，==判断传输的数据是否安全能否解码发给上层？？==
   5. 网络层：将数据传到目标地址，负责寻址和路由选择->我理解就是总线（如果有）上所有的目标主机都会拿到这串数据，而非目标主机则不会收到数据
   6. 数据链路层，这一层应该属于硬件层面了，协议会根据通信的方式，比如wifi/路由器的方式的不同而不同
   7. 物理层，这一层就是把之前所有的数据转成比特0和1，即计算机信号发送了
2. TCP/IP
   1. 应用层，这里就有大名鼎鼎的==HTTP==协议了
      1. 浏览器和服务端之间的通信用的是HTTP协议
      2. 文件传输 ==FTP协议==
      3. 远程登录 ==TELENET 和SSH==
   2. 传输层：这个是用端口号来识别是那些程序之间相互通信的
      1. ==包含了TCP协议==，这个TCP协议很可靠，可以处理很多异常情况，但是问题就是他为了建立和断开连接，要七次发包收包，所以这个会导致网络流量的浪费，不利于视频之类的传输（为了解决这个问题，定义了许多复杂规范）
      2. 包含==UDP==协议，甩手掌柜型，无连接的传输层协议，发完就不管我事了，对方有没有收到需要应用自己实现，常用于视频、广播之类的地方
   3. 网络层：相当于OSI的第三层，网络层，使用的是IP协议
      1. IP是什么
         - IP是协议
         - 他是指跨越网络发送数据包，使整个互联网都能收到数据的协议
         - 怎么传输数据包？-》用IP地址作为标识
         - 他==不具备重发机制==，就是没发送成功也不管，发就发了，属于非可靠性传输协议，但是为了这个问题，又多了一个ICMP协议
         - ICMP协议，如果双方都有这个协议，一旦IP协议发送的数据包无法到达对方，那就给发送端发送一个异常通知
   4. 网卡层（网络接口层/数据链路层）：这个可以跟下面合起来称网络通信层，这个就是说，配合你的硬件还要有软件驱动的协议配合，才能提供服务
   5. 硬件（这个可有可无，是因为TCP|IP协议是确定互联的设备能通信的前提下提出来的，所以算不上第五层）

#### 两个模型的差异点和共同点？

 OSI的模型更加细化，但是实际执行起来很麻烦，而TCP/IP模型将复杂的模型进行了简化，方便各个厂商的开发

#### 实际上linux系统用的是TCP/IP模型



![image-20231206235843555](D:\study\日报&周报\img\image-20231206235843555.png)

## 相关协议

#### IP（负责传输的IP协议）---网络层

> IP协议的作用是把各种数据包传输给对方（数据包是网络传输的最小单位）,而确保发送到对方那要满足很多条件，最重要的两个是IP地址和MAC地址
>
> ​	IP地址可以换，是指节点分配到的地址
>
> ​	MAC地址是网卡所属的固定地址，基本上不会换

#### TCP(负责可靠性的TCP协议)--传输层

> TCP协议用来提供可靠的字节流服务
>
>  - 什么是字节流服务？--》将大块数据分割成以报文段（segment）为单位的数据包进行传输
>
> - 可靠怎么可靠？--》三次握手
>
>   > ​	重点的两个**TCP**的标志 **SYN**和**ACK**（synchronize和acknowledge）
>   >
>   > 1. 发送端发送一个带SYN标志的数据包给对方
>   > 2. 接受端返回一个SYN/ACK标志的数据包表示确认了信息
>   > 3. 发送端再发送一个ACK标志的数据包代表握手结束

#### DNS(负责域名解析的DNS服务)---同HTTP一样处于应用层

他提供域名到IP地址的解析服务

![image-20231207002545814](D:\study\img\image-20231207002545814.png)

#### HTTP协议！！！

 - HTTP是无状态协议，也就是说HTTP这个响应没有持久化处理，发了就发了就不记得了

 - HTTP使用URI定位网络资源

 - HTTP的方法

   	- get：获取资源
      	- post：传输实体主体
      	- put：传输文件之类的，但是Http1.1的put方法不带验证机制，所以不要用
         	- Head:获取报文首部
   	- DELETE:根据URI删除指定资源，跟put一样不安全
    - OPTIONS:询问支持的方法
      	- ![image-20231207004326286](D:\study\img\image-20231207004326286.png)

   - TRACE:追踪路径
   - ...

- 持久连接：之前的HTTP每次连接都要TCP握手三次，浪费性能，现在HTTP1.1所有连接都是默认持久连接（任一端没有提出断开，就一直连接）
- 持久连接使得管线化成为可能：就是发送请求不用等发送成功，并行发多个请求

##### cookie的诞生

1. 因为HTTP是一个无状态的协议，没有持久化，但是又想要去管理客户端的状态（比如一次登录，访问各个界面）让服务端管理是管不过来的，然后就有了Cookie，Cookie就是说，发送请求拿到响应后setCookie，下次发的时候带上Cookie，服务端就知道你已经登录了

##### HTTP报文和HTTP信息

	-  报文大致分为报文首部和报文主体，两个用空行来区分
 -  获取部分内容的范围请求
    	-  ![image-20231207005854719](D:\study\img\image-20231207005854719.png)

## URI和URL

- URL指的就是网页地址 www.baidu.com
- URI是Uniform Resource Identifier的缩写

> URI是用字符串标识某一互联网资源，而URL是表示资源的地点，可见URL是URI的子集

## HTTP报文内的HTTP信息

- 请求报文和响应报文，大致分为报文首部和报文主体两块， 报文中以空行为分割（CR+LF）
- 分割发送，范围i请求+首部range来指定byte范围

## HTTP状态码

- 2XX 成功
- 3XX 重定向
- 4XX  客户端错误
- 5XX 服务器错误

## 与HTTP协作的Web服务器

	- HTTP1.1规范允许HTTP服务器搭建多个Web站点，就是可以运行多个不同的网站
	- 但是比如一个服务器运行了多个网站，客户端在访问的时候，会采用 www.aaa.com或者www.bbb.com这种方式，但是在互联网上经过DNS服务转换之后，会变成相同的域名 比如              “http://.192.125.28:8080” ,这时候要弄清楚到底访问的是哪个的话，就要在Host首部内完整指定主机名或域名的URI

- 代理、网关、隧道
  - 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人"的角色，`接收由客户端发送的请求并转发给服务器`，同时也接收服务器返回的响应并转发给客户端。
  - 网关 是`转发其他服务器`通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关
  - 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并`保持双方通信连接`的应用程序。



![image-20231213010052025](D:\study\img\image-20231213010052025.png)

HTTP请求的一些首部，可以使得http请求更加定制化

​	![image-20231213010209015](D:\study\img\image-20231213010209015.png)

有时候，服务器返回的是缓存里面的数据，可以利用首部，去选择接受哪些数据

[[HTTP报文是什么样子的]]
## 应该如何理解请求方法

- 目前HTTP/1.1里面规定了八种方法，单词还必须是大写的

  - GET ：获取资源

  - HEAD： 获取资源元信息，只返回响应头，就是所谓的元信息

  - POST： 向资源提交数据

  - PUT：类似于POST

  - DELETE：DELETE，删除资源

  - CONNECT：建立特殊的连接隧道

  - OPTIONS：列出可对资源实行的方法

  - TRACE：追踪请求

    请求是否接受是由服务器判断的，服务器可以返回 200 404 403 405 等

### GET

get方法就是基本的获取资源的方法，但是可以搭配URI实现更精细的操作

比如 在URI使用“#”就可以获取页面后直接定位某个标签的位置

==使用 If-Modified-Since  就变成了有条件的请求，仅当资源被修改的时候才会执行获取动作==

### HEAD

**HEAD**方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。

HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，==避免传输 body 数据的浪费。==

### POST/PUT

post就是发送请求，把请求放在请求body里面，然后拼好POST请求头，通过TCP协议发送给服务器，

PUT基本类似于POST，所以基本不用了，与post不同的就是他更倾向于更新

### 其他方法

**DELETE**方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，==更多的时候服务器就直接不处理 DELETE 请求。==

**CONNECT**是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了==代理==的角色。

**OPTIONS **方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。==这个在工作中遇到过，跨域的时候，chrome服务器会先发送一个opional方法，通过了才发送真正的跨域请求==

**TRACE**方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

### 安全和幂等

关于请求方法还有两个面试时有可能会问到、比较重要的概念：**安全**与**幂等**。

在 HTTP 协议里，所谓的“**安全**”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。

所谓的“**幂等**”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

很显然，==GET 和 HEAD 既是安全的也是幂等的==，==DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的==。

POST 和 PUT 的幂等性质就略费解一点。

`按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。`

`对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。`




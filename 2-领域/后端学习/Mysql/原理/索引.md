---
created: 2024-03-03
updated: 2024-03-03
Type: knowledge
Status: ⌛️ 等待
tags:
---
## 索引的常见模型
索引实际上可以理解成目录，一种方便快速查询的目录。
但是说到索引，就需要引出一些适合索引查询的数据结构，索引实现方式有很多种，一些特定的数据结构能更好的实现索引的功能，下面简单介绍三种

1.  哈希表
	1.  哈希表是一种以 key-value 的形式存储数据的结构
	2. $ 其优势在于插入的时候很快，同 id 就是往后加链表，所以插入新数据很快
	3. & 劣势在于因为不是有序的，所以做**区间查询**还是要遍历所有的 key，速度很慢
	4. ~ 所以哈希表这种结构只适合于**等值查询**的场景，比如一些 nosql 引擎
2.  有序数组
	1.  而有序数组在等值查询和区间查询的表现都非常优秀
	2. 在等值查询的时候（就是用 key 查 value）可以直接二分法快速查到
	3. 区间查询更是只要选定区间就能查询
	4. & 但是，其缺点在于新增数据的时候，要整体移动插入数据后面的所有数据的位置，新增很慢
	5. ~ 所以有序数组只适用于静态存储引擎，比如 2017 年某个城市人口信息这类不会再变动的数据
3.  二叉树
	1. 二叉树的结构如图![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303163256.png)
	2. 他的特点是节点是中间节点，也就是子节点，小于右边的叶子节点，大于左边的叶子节点，他的查询复杂度是 o(logN)，更具体的看[[平衡多路查找树（B树）]]
	3. 树可以二叉，也可以多叉，这个多叉是值每个节点有多个叶子节点，二叉树是搜索效率最高的数据结构
	4. & 但是实际上大多数的数据库存储不使用二叉树，原因在于**索引不止存在内存中，还要写到磁盘上**
		1. ~ 关于这点你可以想想一下，一颗一百万节点的平衡二叉树，树高 20 ，而机械硬盘时代，从磁盘随机读取一个数据块需要 10ms 的寻址时间，而 20 块就是 20 个 10ms，读取的效率过于低下 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303164041.png)
	5. 所以实际上我们使用的是 N 叉树，这里的 N 取决于数据块的大小，以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

在 mysql 中，索引是在储存引擎层实现的，没有固定的索引标准，而 mysql 中用的最广泛的就是innoDB

## InnoDB 的索引模型

在 innoDB 中，表是根据主键顺序以索引的形式存放的，这种存储方式成为索引组织表，而 InnoDB 采用了 B+树的模型，所以数据都是存放在 B+树中的[[平衡多路查找树（B树）#B+树]]

==每一个索引在 innoDB 里面对应着一颗 B+树==

### 举个例子
创建一个表，字段 k 上有索引

```sql
create table T( id int primary key, k int not null, name varchar(16), index (k))engine=InnoDB;
```

假设里面储存了多个数据（>5）其中五个数据（R1->R5）如下， (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，那么这两颗树示意图如下 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303194609.png)
从图中不难看出，根据叶子节点的内容，索引类型分为**主键索引**和**非主键索引**
1. 主键索引的叶子节点存的是整行数据，在 InnoDB 里面也被称为**聚簇索引**
2. 非主键索引的叶子节点内容是主键的值，在 innoDB 里面非主键索引也被成为**二级索引**
由上我们就可以知道
- ~ 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
- ~ 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。
==所以我们在应用中要尽量使用主键查询==

## 索引维护
B+树为了维护索引的有序性，在新插入值的时候需要做必要的维护
所谓维护，就是指在插入数据的时候做出必要的维护而保证整体的数据结构的操作

### 举个例子，插入新值
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303194609.png)
以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

下面整段摘抄[04 深入浅出索引（上）](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/04%20%20%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e7%b4%a2%e5%bc%95%ef%bc%88%e4%b8%8a%ef%bc%89.md)
> 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
> 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
> 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。
> 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
>
>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。
>
>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
>
>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
>
>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
>
>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。
>
>**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
>
>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。


>[!faq] 还有一个需要讨论的案例，有没有什么业务场景适用于业务字段直接做主键的呢？
> 比如有的业务场景是这样要求的
> 	
> 	1. 只有一个索引
> 	2. 该索引必须是唯一索引
> 
> 这就是典型的 KV 场景，这时候我们就没有其他的索引储存 id 值从而出现上面的那种情况（指占用空间问题），所以不用考虑其他节点的叶子节点大小问题，而我们又有尽量使用主键查询的原则，直接将业务字段设置为主键，可以避免每次查询需要搜索两颗树


## 覆盖索引

### 引入问题
我们先可以看一下这个问题

先创建一个表
```sql
create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; 
insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```
得到表结构如下![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303203705.png)

现在我要执行一个 sql 语句
```sql
	select * from T where k between 3 and 5
```

>[!faq] 需要执行几次树的搜索操作，会扫描多少行？
>现在，我们一起来看看这条 SQL 查询语句的执行流程：
>
>1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
>2. 再到 ID 索引树查到 ID=300 对应的 R3；
>3. 在 k 索引树取下一个值 k=5，取得 ID=500；
>4. 再回到 ID 索引树查到 ID=500 对应的 R4；
>5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。
>
>在这个过程中，**回到主键索引树搜索的过程，我们称为回表**。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。
>
>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2

那我们有没有办法经过索引的优化从而避免回表的过程呢？

### 什么是覆盖索引
如果我们执行的语句是 
```sql
select ID from T where k between 3 and 5;
```
只需要查 id 值，而 id 的值已经在 k 索引树上了，因此我们可以直接提供查询结果，不需要回表，这里索引 K 已经"**覆盖**"了我们的查询需求，所以称之为覆盖索引

**覆盖索引是一个常用的性能优化手段**

所以联合索引的意义就出来了，举个例子

我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是**有代价**的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。


## 最左前缀原则
在真实的搜索场景中，我们有很多其他的场景，比如身份证和房屋啊，或者其他的，那如果要为每一种查询都设计一个索引又是不是太多了？尽管可能某个搜索频次不高，但是总不能全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？

但是实际上，B+树的索引



## 小结
1. 本次我们学习到了索引模型，以及较为重要的二叉树-> N 叉树的模型
2. mysql 最多使用的引擎是 innoDB，里面的索引模型是 B+树
3. 在 InnoDB 中，每一个索引都是以一颗树的形式存储的，
	1. 主键索引又叫群簇索引，他是储存整行数据的
	2. 其他索引（非主键索引）里面储存的是 id 值
		1. & 这里要注意的是 id 值在其他索引里面是占空间的，id 值过长的话，其他索引里面存储的空间就会变大，造成性能上的浪费，所以我们推荐自增形式的索引
		2. 在 innoDB 里面也被称为 2 级索引
		3. & 通过非主键索引搜索的时候，会先遍历这个对应的索引树，找到对应的 id，然后再遍历 id 索引树，这个称之为回表，所以我们推荐尽量使用主键索引
4. 某些业务场景 KV 场景，可以直接用业务字段做主键

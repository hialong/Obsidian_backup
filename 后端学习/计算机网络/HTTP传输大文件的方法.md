---
Created: 2024-01-17
Updated: 2024-01-25
Type: knowledge
Status: 🌱 活跃
截止日期: 
目标: 
领域: 
tags:
---
>Http 可以传输很多种类的数据，不仅是文本也能传输数据，甚至是图片视频，但是有一点需要注意，如果文件很大，如何在有限的带宽下高效快捷地传输这些大文件？
- [x] 未完待续 ✅ 2024-01-25

> HTTP 不仅能传文本，也能传输图片，音频，视频所以我们需要解决，如何在有限的带宽下，高效快捷的传输这些文件
## 数据压缩

首先一个方法就是，压缩，我们常见的 zip gzip 等，实现过程就是浏览器在发送请求的时候，会在请求头里面加上"Accept-Encoding"头字段，告诉服务器浏览器支持的压缩类型（gzip, deflate 等），这样服务器就会选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器。

但是**缺点**是这种方式其实只对文本类型有较好的支持，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了
## 分块传输
如果不能压缩，那我们就可以采取分块的方法，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原
这样做的**意义是**浏览器和服务器都不需要在内存里保存文件的全部，网络也不会被大文件长时间占用

### 怎么做？（分块传输编码）
在我们发送请求的时候，在响应报文里加上“**Transfer-Encoding: chunked**”，就是表示开始分块传输了
>[!note]
>这里要注意的是，Transfer-Encoding: chunked”和“Content-Length”这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）

### 分块规则？
分块的规则相似于响应头
1. 每个分块包含两个部分，长度头和数据块；
2. 长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；
3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；
4. 最后用一个长度为 0 的块表示结束，即“`0\r\n\r\n`”
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240125000624.png)
需要说明的是，**正常来说，我们是看不到分块的编码的**，因为浏览器在收到分块传输的数据后会自动按照规则去掉分块编码，重新组装出内容，所以想要看到服务器发出的原始报文形态就得用 Telnet 手工发送请求（或者用 Wireshark 抓包），Telnet 抓包的结果如下 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240125000825.png)
可以看到，f 是表示长度的十六进制数，下面则是数据，最后是 0 长度分块结束。
但是分块传输并不能完全解决上 G 的超大文件的传输，我们还有问题需要解决

## 范围请求
范围请求的场景在于，
	比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。

Http 为了满足这样的需求，提出了范围请求的概念，允许客户端在请求头里面使用专用的字段表示只获取文件的一部分，相当于化整为零

范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。

如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了

### 怎么做？
如果支持，浏览器需要怎么发送请求呢，我们就可以在请求头里加上一个字段
```HTTP
Content-Range: bytes=x-y
```
注意记数规则，要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节（和 java 里面的数组很像，都是从 0 开始）

Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：

- “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；
- “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；
- “-1”是文档的最后一个字节，相当于“99-99”；
- “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。

下面是一些注意的地方
1. x, y 必须满足范围，不能越界，否则服务器会返回状态码 416，告诉你范围有误
2. 如果范围是正确的，那么服务器会返回状态码“**206 Partial Content**”，和 200 的意思差不多，但表示 body 只是原数据的一部分 
3. 服务器要添加一个响应头字段**Content-Range**，告诉片段的实际偏移量和资源的总大小，格式是“**bytes x-y/length**”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”

下面举个例子（摘选网络）
例如下面的这个请求使用 Range 字段获取了文件的前 32 个字节：

```http
GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-31
```

返回的数据是（去掉了几个无关字段）：

```http
HTTP/1.1 206 Partial Content
Content-Length: 32
Accept-Ranges: bytes
Content-Range: bytes 0-31/96
 
// this is a plain text json doc
```

不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：

- 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；
- 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；
- 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。

### 多段数据
范围请求其实不止能一次获取一个片段，还支持在 Range 头里使用多个 x-y，一次性获取多个片段数据
这个只在响应的报文支持使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记

这个多段数据的传输比较类似于分块传输，![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240125003143.png) 但是他是用的 boundary 来表示区分不同的片段，这里的 boundary 会在报文里面返回
每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。

例如
```http
GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29
```

得到的就会是下面这样：

```http
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes
 
 
--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96
 
// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96
 
ext json d
--00000000001--
```

报文里的“- -00000000001”就是多段的分隔符，使用它客户端就可以很容易地区分出多段 Range 数据。

## 总结
1. 大文件的传输大概分为三种方式
	1. 压缩--只针对文本表现较好，大部分作为兜底的，标志是请求加上 Accept-Encoding ，响应就相应的返回 Content-Encoding
	2. 分块，分块只解决了传输的痛点，但是没有解决视频之类的请求，其标志是使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块，还有就是和 contentLength 请求头互斥；
	3. 范围请求，这个实现了视频的拖拽和断点续传（很多下载器也是这么搞的），标志是使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206
		1. 然后范围请求还可以多端同时请求，多加一个 x-y 就行，返回的时候类似于分块的返回，就是分割变成了 boundary
	4. 最后，这四种方式，完全可以混在一起，比如压缩后在范围请求、分块传输等
---
Created: 2024-01-17
Updated: 2024-01-25
Type: knowledge
Status: 🎃已完成
截止日期: 
目标: 
领域: 
tags:
---

## Redis持久化

持久化策略，两个策略

- RDB快照（整点切片），通过切片还原数据
- AOF日志：记录日志，可以通过命令恢复

差别
	​相同数据量下，RDB更小，因为RDB记录二进制紧凑型数据库
	​AOF记录了每条日志，RDB是间隔时间记录一次，AOF恢复数据通常更为完整，ADB更快，
	AOF对性能影响比较大，AOF和RDB是可以同时开启的，官网更推荐AOF ^2a63d7



#### 加载策略
- ![image-20231226001133134](D:\\study\img\image-20231226001133134.png)
^7ad171


先判断AOF是否存在，而且不会==降级==（如果开启了AOF，AOF文件不存在也不会去找RDB），aof文件不存在就会启动空库，有aof只会用aof

### RDB详解（快照）

​	dump.rdb -- 快照文件



- 怎么开启

-  save 900 1（save min times）

- 900 秒里面有一次就会开启一次 RDB

- 也可以使用 sava 命令来主动使用持久化

    ![image-20231226234407734](D:\\study\img\image-20231226234407734.png)

    后台持久化，会fork一个子进程开始复制

  - 文件名字 ： dump.rdb

  - 存放位置：看redis
#### 写入流程

1. Fork 一个子进程专门来做 RDB 持久化
2. 子进程写入数据到临时的 RDB 文件
3. 写完之后用新的 RDB 文件替换旧的 RDB 文件
#### 写时复制

如果用的 save 的命令。那么就会阻塞主进程，如果用的 bgsave 命令，那么用的就是从主进程 fork 的一个子线程，用子进程去开始复制，那么这里就有问题，就是子进程在执行的过程中，主进程还能修改数据吗？如果阻塞岂不是跟 save 命令没什么区别，还是会主动阻塞进程？

答案是 主进程当然可以写入数据，依然可以继续执行操作命令
执行 bgsave 命令的时候，会通过 fork（）创建子进程（注意是进程不是线程），**子进程和父进程是共享同一片内存数据的**，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，方便子进程去复制数据 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240125145632.png)
但是当发生内存修改的时候，这块**被修改的**物理内存就会被复制一份，如下 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240125150053.png) 子进程指向就变成了新的物理内存，然后主进程继续自己的写入，子进程继续自己的复制，**发生了写时复制后，RDB 快照保存的是原本的内存数据**，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。

那么极端情况下，**如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。**
所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了

写时复制：写的时候就开始复制，谁写谁复制，fork的过程中如果有新的数据，那就这个数据自己多写一份放到线程里面



#### 面试题

- RDB本质是什么
	​	本质是二进制形式的快照，直接保存二进制的数据到磁盘，后续通过加载RDB文件恢复数据
 ^1010b3
- 如何触发RDB ^1036f5
	- RDB可以通过配置定时触发，触发时使用的是后台持久化方式
	- 也可以主动用命令触发，save和bgsave，save底层用的是阻塞式持久化，bgsave用的是后台持久化
	- 最后如果redis正常关闭，是会触发阻塞式持久化的

- RDB对主流程有什么影响 ^83f61a
	  - 用命令执行阻塞式持久化的时候，由主进程进行RDB快照保存，会阻塞主进程
	  - 当执行后台持久化时，由fork出来的子进程来进行RDB快照保存
	    - 数据量大的时候，会导致fork主进程操作比较耗时，从而阻塞主进程（==耗时会阻塞主进程吗？进程之间阻塞？==）
	    - 由于采用了写时复制，如果在fork期间有大量写入，就会导致主线程多拷贝一份数据，消耗大量额外内存

### AOF详解

 - 是什么
   	- 记录了对应操作的命令，有自己的一套协议记录（==但是只记录写操作，读操作是没有意义的==）


 - 怎么开启
	   	-  也是redis的配置文件，里面有一个appendonly no 改成yes
	   	-  写入的文件名字就是 appendfilename “xxxx”


 - 写入？
   	- 流程：==请求到来->处理请求-> 写入AOF文件== ^852a5e
    - 其中写入 AOF文件又有三个步骤
      	- 命令追加（写入aof_buf）
	      	- 将数据写入到AOF缓存中，实际上就是把日志写到一个sds数据
       	- 文件写入（write 到内核缓冲区）
	       	- 将上一步aof_buf里面的数据里面对应的数据刷入磁盘缓冲区，==那么我们什么时候刷入呢？==
	       	- 事实上有四个时机刷入，会调用一个叫flushAppendOnlyFile的函数，将数据写入系统缓冲区
		       1. 处理完时机，等待下一次事件到来之前，这就是在 ==beforeSleep==中
		       2. 周期函数serverCron中
		       3. 服务器正常退出的时候
		       4. 通过配置指令关闭AOF功能的时候
       	- 文件同步（fsync到磁盘）
          - 刷盘策略（当我们设置的刷盘策略（appendfsync）不同，刷盘的情况也不同）
            1. always 每次请求都刷盘，非常慢，但是很安全，性能开销很大，==而且这玩意是直接主线程刷盘的==
            2. everySec 每秒刷一次，足够快了，但是可能丢失一秒的数据
            3. appendfsync no 不主动刷盘，让操作系统自己刷，一半linux30秒刷一次，对性能影响比较小，但是如果崩溃，可能会丢失比较多的数据 ^013abe


 - aof重写（优化aof里面的重复数据，比如set a1 1 然后覆盖了 set a1 2,就会合成一个） ^0a9ef9
    - 为什么要重写
	    -因为AOF是不断写入的，这样带来一个问题就是AOF文件会变得非常大，无限制的膨胀，针对这个问题，Redis采用了重写的方式来解决问题
	- 怎么做？
      	- ![image-20231227001640372](D:\\study\img\image-20231227001640372.png) ^a8ab5a
		- 当redis发现AOF文件过大的时候，就会在==后台Fork一个子进程==（进程不是线程，Redis是单线程的），专门针对AOF进行重写，简单来说就是合并一些重复的操作，比如set同一个key之类的
		- 重写的过程中，Redis不但将新的操作记录在原有的AOF缓冲区[[#^0a9ef9|看里面的命令追加那一块]]，而且同时会记录在AOF的重写缓冲区，一旦新的AOF重写好了，Redis就会把缓冲区的直接追加到新的文件里面，然后用新文件替换旧文件
	- 什么时候重写?
		-配置决定的，默认情况下是，==超过64M的情况下，相比上次重写时的数据大一倍==，则触发重写，很明显，最后实际上还是在周期函数来检查和触发的。

#### 面试题

​aof不是默认开启，rdb是默认开启的

aof对主流程有什么影响？
	1. 如果我们使用的是 always 的策略，Redis执行命令之后，就会需要==主线程==进行write+fsync的操作[[#^852a5e]]，导致主线程处理其他请求会变得很慢
	2. 如果策略用的是everySec，如果后台线程上一轮的fsync没有完成，会导致我们本轮主线程执行write被阻塞
	3. AOF重写是由fork出的子进程进行的，类似于上面提到的风险，fork子进程这个操作有可能阻塞主进程 ^f91732

### AOF优化

- aof的不足

  - 文件体积大，加载速度慢
  - 重写性能差，重写流程复杂，代码难度高

- ==混合持久化==（redis配置文件中打开） ^125e38
	- **混合部署实际上发生在AOF的重写阶段**
	- 是什么？
		- 重写发生时候，将当前状态保存为RDB二进制内容，把这个RDB的内容写入到新的AOF文件中，然后跟前面重写流程一样会把缓存区的内容追加进来，最后代替原有的AOF文件[[#^a8ab5a|重写流程]]
	- 解决了什么问题？
		- 优化了重写的流程，RDB是快照 [[#^1010b3|RDB本质]]，使得重写更快，大大降低了AOF重写的性能损耗
	- 怎么开启？
		- 打开redis配置文件，5.0之后是默认打开的
	- 实际流程是什么样子？
		-![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240107194100.png)
		前面说过，如果同时开启了RDB和AOF，那么优先会去找AOF文件  [[#^7ad171|加载策略]]，那么这里如果开启了混合持久化，也会去优先找混合持久化的文件


  

  

- 优化方案

![image-20231227003741271](D:\\study\img\image-20231227003741271.png)

优化之一,下面去掉了重写缓冲区，去掉了子线程合入两个文件，直接两个文件放一起，由manifest清单（7.0的优化)

![image-20231227004031822](D:\\study\img\image-20231227004031822.png)



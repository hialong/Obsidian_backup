---
Created: 2024-01-17
Updated: 2024-01-17
Type: knowledge
Status: 🌱 完成
截止日期: 
目标: 
领域: 
Tags:
---
事务是什么？
	多个操作被视为一个整体，就是事务，事务通常具有原子性

### Multi 事务
Redis 原生有 Multi 命令，可以开启事务，实际上是由 `MULTI`、`EXEC`、`DISCARD`、`WATCH` 这四个命令配合完成的

怎么操作？
	1. Multi 即开启事务
		`127.0.0.1:6379>multi`
		`OK`
	2. 此时进行的事务都会到 Redis 队列里面, 但是不会真正执行
		`127.0.0.1:6379 (TX))>set k1 aa`
		`QUEUED`
		`127.0.0.1:6379 (TX))>set k2 bb`
		`QUEUED`
	3. 实际执行
		`127.0.0.1:6379>exec`
		`1) OK` 
		`2) OK` 
	4. 这个时候 get 命令就能查到这俩了
		`127.0.0.1:6379>get k1`
		`"aa"`
		`127.0.0.1:6379>get k2`
		`"bb"`
	5. 放弃执行事务就是
		`127.0.0.1:6379>DISCARD`
		`OK` 
		`127.0.0.1:6379>get k1`
		`(nil)`
	6. WATCH 命令
		1. Watch 用来提前来观察数据，具体来说，它用于监视一个 (或多个）key，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断
		2. 一般的操作是：在**multi 命令之前使用 watch 命令监控某些键值对**，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这些命令会进入先入先出队列中
		3. 当 redis 使用 exec 命令执行事务的时候，首先**会比较对被 watch 的键值对有没有发生变化**，如果产生变化回滚事务，没有变化执行事务中的命令，无论事务执行与否，最终都会取消执行事务之前的 watch 命令
		4. ==总结：就是说，如果你这个 key 在你操作的时候，被别人改了，那你就回滚事务==
		5. 例子如下（前提是你先 Watch 了） ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240114225819.png) 可以看到最终是没有修改成功

那么 MULTI 有原子性吗？答案是没有，他只是通过单线程的特性，让其他操作切不进来，如果中途发生了什么，或者自己有问题还是可能只做了一半，**甚至中间报错，后面还是能成功，这是很捞的一件事**


### LUA 做事务

>Lua 是一种用标准 C 语言编写的轻量的脚本语言，陈其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。可以看到 Lua 的目标就是为应用程序提供扩展

使用的例子
```BASH
127.0.0.1:6379>eval "return {redis.call('set','ka', 'a'), redis.call('set','kb', 'b')}" 0
1) ok
2) ok
```

#### LUA 事务分析
先提出几个问题
1. lua 事务失败会怎么做？
2. 相比 multi 的优势在哪？
3. 有哪些场景？

首先第一点，失败会怎么做？
	不会，会中断，不会进行后面的步骤，也就是不能保证完全的原子性，也说明了不能完全依赖分布式锁

第二优势就多了
1. lua 可以编写 if else 来写逻辑
2. 事务中间如果失败，会中断后续执行
3. 方便，不需要 multi 的 Watch，直接开始就行
4. 场景就是[[分布式锁（很重要）]]和秒杀

### 分布式锁是什么

首先，锁可以理解为针对某项资源使用权限的管理，通常用来控制共享资源, 而分布式锁，顾名思义，是在分布式环境下的锁，用来管理多台不同机器上的线程，竞争同一项资源

### 分布式锁应该具备哪些特性？

1. 互斥性
	锁的目的是保证同一时刻只有一个线程持有锁，所以要保证互斥
2. 安全性
	需要避免锁因为异常的出现而永远不被释放，需要有兜底的释放锁的能力，并保证后续其他竞争者也能加锁
3. 对称性
	同一个锁，加锁解锁的必须是同一个对象，不能解锁别人的锁
4. 可靠性
	需要能处理一定程度的异常，而且要有容灾的能力

### 分布式锁常用实现方式
#### 最简化版本

最简化版本就是直接使用 Redis 的 setnx 命令，这个命令如果 key 存在，那么会返回 0，不会影响该数据
```bash
setnx key value
```
基于这个特性，我们就可以利用这个方式加锁解锁了
1. 互斥性：具体实现如下：
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111221311.png)
	通过 setnx 进行锁的操作

但是这么做==解决了互斥性==的问题，但是==安全性和可靠性还有对称性该怎么解决==？[[#分布式锁应该具备哪些特性？]]
2. 安全性
	==安全性==当然是支持过期时间了，这样可以保证一旦一个线程持有锁时间太长，就会自动解锁，保证服务能继续进行下去，但是这时候又引入了一个新的问题，怎么加过期时间，虽然 Redis 提供了 setNx 方法 [[RedisString的编码以及操作#^244caf|set的一些操作]]，但是 setnx 和 expire 不具备原子性，也就是说，如果是 `setnx key value` 然后再 `expire key 100` 这种操作可能在中间（服务器宕机）就断掉了，所以 Redis 官方也提供了原子性的写法 `set key value nx ex seconds `
```bash
set key value nx ex seconds 
```

3. 对称性
	上面的解决了安全性的问题，保证了一个锁不会被长时间占有，但是还存在一个重要问题，这个锁可能会被别的进程解锁
		**例如**：由于业务流程比较长，或者网络延迟 GC 卡顿等原因，导致锁过期，而业务还会继续进行。这时候，业务 B 已经拿到了锁，准备去执行，这个时候服务 A 恢复过来并做完了业务，就会释放锁，而 B 却还在继续执行。那就是说，A 把 B 的锁强行释放掉了
	所以我们需要进一步的解决方案，那就是设置 ownerId ，即每个人只能释放自己的锁，==遵循谁申请谁释放==
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111230557.png)
	这样，每次获取锁的删除锁的操作，都检查锁的名称对不对，不然不删除，**这就解决了对称性的问题，但是实际上并不完善**
	因为很明显，你看删除锁的流程，获取锁->返回值->删除锁，这三步不是原子操作，那么在分布式的环境下就有一个大问题，你获取的时候，锁是你自己的，但是你删除锁的时候，其实是其他人的锁，因为这些操作不具有原子性，所以我们就引入了 Redis 的特性 [LUA](https://www.runoob.com/lua/lua-tutorial.html), 使用 LUA 脚本，我们可以获得原子性的操作的能力
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240111231447.png)
- [x] Reids 分布式锁还没写完，未完待续 ✅ 2024-01-12

1. 那么上面的其实就解决了三个重要特性，互斥性，安全性，对称性，还有最后一个，可靠性，也就是说，需要解决的是，针对一些异常场景，网络波动、服务器挂掉、业务执行时间过长，要怎么解决, 一般来说，有两种大的解决办法
	1. [[#主从容灾]] 
	2. [[#多机部署]] 

下面简单介绍一下
##### 主从容灾

主从容灾就是最简单的方式，即为 Redis 配置从节点，从节点挂了就用主节点顶上去，Redis 有了成熟的解决方式，就是**哨兵模式**
	1. 哨兵模式就是说，哨兵总事以固定的频率去发现节点、故障检测，然后在检测到主节点故障时以安全的方式执行故障转移，确保集群的高可用性
	2. 一般情况下，哨兵节点每隔 10 秒（故障转移时每隔 1 秒）向主从节点发送 `INFO` 命令，以此获取主从节点的信息。第一次执行时，哨兵仅知道我们给出的主节点信息，通过对主节点执行 `INFO` 命令就可以获取其从节点列表。如此周期性执行，就可以不断发现新加入的节点
	3. 因为哨兵模式有同步的延迟，很可能使得数据丢失，也可能导致分布式锁失效
	4. 具体的可以看这篇[什么是哨兵模式](https://zhuanlan.zhihu.com/p/354720754)
- [ ] 可以到时候再把哨兵模式的流程整理成一个文档
##### 多机部署
相对于哨兵模式，多级部署是更可靠的方法，多机部署对一致性的实现更高一点，比如 Redis 的 RedLock，大概的思路就是多个机器，通常是奇数个，**达到一半以上同意加锁才算加锁成功**

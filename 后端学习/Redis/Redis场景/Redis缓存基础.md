> 由于Redis性能高效，通常可以用作数据库储存的缓存，常见的就有给Mysql的热点数据做缓存的玩法，可以很大程度的提升系统的吞吐量


缓存是什么？
	- 缓存分为两种，服务器缓存和客户端缓存
		- 服务器缓存就是指服务端将数据存入Redis，这样在访问DB之后，可以将从DB得到的数据缓存起来，下次访问就从缓存拿，而不走DB
		- 客户端缓存就是客户端自己把之前储存的结果放在缓存里面，下次再请求时候就能直接拿到结果

## 缓存的几种模式

> - Cache Aside Pattern 旁路缓存模式
>- Read Through Cache Pattern：读穿透模式
>- Write Through Cache Pattern：写穿透模式
>- Write Behind Pattern：又叫Write Back，异步缓存写入模式

### Cache Aside

是什么？
	旁路缓存模式，即最常见的模式，应用的服务会直接把缓存当作数据库的旁路，并==直接和缓存进行交互==，读先读缓存，写先写内存

读流程
	流程如下图
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240107224814.png)
	简单来说，优先访问缓存，缓存没有再去查db，然后更新缓存，再返回数据

写流程
	流程如下
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240107224939.png)
	写操作的时候，如果是新增，那就是写入数据库然后更新 Redis 缓存，那如果是更新，就有点需要注意了，更新的时候优先写到数据库里面，然后尝试==直接删除缓存==，那么为什么不更新呢？因为更新相比删除，会更容易出现时序性的问题[[缓存一致性怎么保证]]，还有个需要注意的地方是，为什么说是尝试删除，因为删除是可能失败的，如果失败我们就会选择忽略，因为还有过期时间兜底 ^67a07b

适用场景
	由于写操作的时候直接删除缓存，那么很显然这个更适合于写操作少的场景，读多写少

缺点
	缺陷在于，可能会出现缓存和数据库不一致的情况 [[#缓存和数据库不一致的问题]]
	

[[缓存一致性怎么保证]]

### Read Through

是什么？
	读穿透模式，就是Redis起了一个服务，由这个服务呢去访问数据库和缓存，服务根据自身情况去判断怎么做，类似于Service Dao层的管理模式，跟[[#Cache Aside]]不一样的就在于，他是将具体的逻辑封装起来了，跟[[#Cache Aside]]相比，业务代码会更简洁一点，但是缺点在于，多进行了一次服务的调用，缓存命中的时候，性能不如[[#Cache Aside]]
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240108203039.png)



### Write Through

是什么？
	相对于 [[#Cache Aside]] 应用程序需要维护两个数据，一个缓存一个数据库，操作比较麻烦，所以Write Through相当于做了一个封装，封装了一个单独的服务，应用程序就只有一个访问源，服务自身维护自己的访问逻辑
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240107231718.png)
	他的特点在于
		- 缓存的及时性更高，写入时候就加载了缓存里面，当然可能会有时序问题
		- 不能忍受数据丢失，和数据不一致，当然Cache Aside也是这样


怎么用？
	这个模式是有配合的，有Write-Through 一般都配合Read-through 一起使用，

使用场景
	一般是银行场景用的多

优缺点
	优点在于缓存及时，数据写入就加入了缓存，但是缺点也在于此，由于写入时同时写入了缓存，所以会导致缓存到后面变的很大，需要考虑缓存的时效性，让缓存及时过期

### Write-Behind

是什么？
	 和[[#Write Through]]一样都会在写入的时候，更新数据库且更新缓存，但是并不是立即写入数据库，当数据写入时，先写缓存，然后==异步把数据一起写入数据库==，异步写操作时其最大的特点，[[#数据库的写]]
	![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240108204434.png)



#### 数据库的写

数据库的异步写入可以用多种方式完成，下面两种是可以结合的
	-  一个是收集写操作，等到某一个时间点的时候（比如就是数据库负载低的时候）再一起写入
	- 一个就是合并几个写操作，然后一起批量写入，即集中写入

异步写入可以极大的降低数据库的负担，但是代价是安全性不够，比如你先写入了缓存里面，准备异步写入的时候，服务器崩了，那数据就消失了


### ！！！常用的操作
怎么设置缓存？
	1. 一般来说，Redis缓存用的就是Set命令，Set key value 如果业务需要，后面还能加一个ex当过期时间，set key value ex 10 ^7205e7


### 总结
1. 四种模式怎么选择？
	[[#Cache Aside]]是最常用的，其他的在业务开发的时候很少会用到
2. 几个缓存的场景总结
	1. Cache Aside 读是先读缓存再读数据库并更新缓存，写的时候则是直接删除缓存
	2. Read Through 类似于封装了一层Service的Cache Aside，业务上更简洁，性能却不如Cache Aside
	3. Write Through 也是封装了服务，但是逻辑上变了，缓存和内存的同时写入，带来了及时性（可能有时序性问题），也带来了巨大的缓存量
	4. Write-Behind 异步写的操作是特点，能够降低数据库负担，但是安全性不足
3. 如何保证缓存一致性呢？--> 见[[缓存一致性怎么保证]]
---
created: 2024-02-20
updated: 2024-02-20
Type:
  - knowledge
Status:
  - ⌛️ 等待
tags:
  - 数据结构
aliases:
  - 平衡二叉树、B树、B+树、B*树
---
## 从二分法到二叉树
首先介绍二分法，二分法是我们常用的一种查找算法，具体实现思路如下
1. ~ 首先对数据集进行排序。
2. ~ 找到数据集中间位置的节点。
3. ~ 用查找的条件和中间节点进行比较，等于则直接返回，中间节点数据小于查找条件则说明数据在排序列表的左边，大于则说明数据在排序列表的右边。

也就是说，如果我们能保证数据的有序性，并且预先把数据分段，然后把数据的中间节点储存好，那么查找的时候就会更简单，所以我们演化出了跳表  [[Redis 跳表]] 和**树**的结构

下面就是树的结构![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220233103.png)
>[!note] 那么这个就是二叉树

## 从二叉树到平衡二叉树
>[!faq]- 我们构建二叉树需要怎样的操作呢
>平衡算法
>相同的数据插入的先后顺序不一样就可能变成线性结构，如下 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220233502.png) 所以我们必须要有一种方式来保证二叉树节点的平衡，让树的节点高度差不会太大，这个时候就衍生了一些平衡算法，最终我们的二叉树就有像 AVL 树和红黑树这些新产品，我们也称这些新产品为**平衡二叉树**，，平衡二叉树通常会保证树的左右两边的节点层级相差不会大于2。


![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220234020.png)


![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220234031.png)


### 平衡二叉树
当二叉树节点分布不均匀的时候，会极大影响数据查询的性能，为了保证数据的均衡性，就有了平衡二叉树的结构，平衡算法暂不赘述，有时间看看
- [ ]  平衡算法可以研究一下
这里讲一下**构建规则**
#### 平衡二叉树的构建规则
三大特点
1. ~ 非叶子节点只能允许最多两个子节点存在
2. ~ 每一个节点左边子节点值小于当前节点，右边值大（算法算出来的值）
3. ~ 通过平衡算法（比如 Treap、AVL、红黑树）保证左右节点的高度相差不超过 2 层

### B 树
- [x] 没写完到时候看这个 [平衡二叉树、B树、B+树、B\*树 理解其中一种你就都明白了 - 知乎](https://zhuanlan.zhihu.com/p/27700617) 📅 2024-02-22 ✅ 2024-02-22
B 树和平衡二叉树的不同之处是：B 树属于多叉树又名平衡多路查找树（查找路径不止两个），数据库索引技术里大量使用着 B 树和 B+树的数据结构。
- & 注意 B 树和 B-tree 是同一种树

#### B 树的构建规则

有四大特点，说实话没太明白
1. 排序方式：所有关键字是按**递增次序**排列，左小右大
2. 子节点数：非叶节点（根节点和枝节点）的子节点数 >1、且子节点数<=M、且M>=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2则是2叉树,M=3则是3叉）
3. **关键字数**：枝节点的关键字数量大于等于 ceil(m/2)-1个且小于等于 M-1（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2);关键字就是指的是一个节点里面的'值'的数量，==比如下面的图，M 是一个关键字，他有两个子树，DG 是两个关键字，下面有三个子树==，每一层加 1
4. 所有叶子节点均在同一层、叶子节点除了包含了关键字 和 关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

上面比较难理解，下图可以看 B 树，通过他的插入和查询可以很好的理解 b 树 ![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222222707.png)
#### B 树的查找流程
他的查找过程如下
如上图我要从上图中找到E字母，查找流程如下

1. 获取根节点的关键字进行比较，当前根节点关键字为 M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；
2. 拿到关键字 D 和 G，D<E<G 所以直接找到 D 和 G 中间的节点；
3. 拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；

#### B 树的插入流程
1. ~ 定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28、53 这些数字构建出一个5阶树出来
	1. 节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）
	2. 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则
	3. % 首先插入 3、8、31、11![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223559.png)
	4. % 然后插入23、29![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223641.png)
	5. % 最后插入 50 28 53![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223707.png)


#### B 树节点的删除

![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222224333.png)

1. 节点合并规则：当前是要组成一个5路查找树，那么此时 m=5,关键字数必须大于等于 ceil(m/2)-1（所以这里关键字数<2就要进行节点合并）。
2. 满足节点本身比左边节点大，比右边节点小的排序规则。
3. 关键字数小于二时先从子节点取，子节点没有符合条件时就向父节点取，取中间值往父节点放。
### 额外注释

![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222225201.png)
上图数字 1、3、7是叶子节点；（因为他们下面没有分叉出子节点，所以称为：叶子节点）【度为0】  
数字2、8是子节点； （除了根节点、叶子节点之外的，都称为：子节点）【度为1】  
数字5是根节点；（因为他是最顶部，所以称为：根节点）【度为2】
### 总结
平衡二叉树和 b 树都是一种数据结构，他们的特点是平衡，这种结构能让人更快的查询到需要的数据，两者的查询使我们能够在最坏情况下也保持 O(LogN)的时间复杂度实现查找，两者也有**区别**

==平衡二叉树：==
1. 平衡二叉树从二叉树过来，因为二叉树的规则，**左小右大**不足以控制二叉树的高度，可能会出现二叉树变成一条线性结构的情况出现，所以加上了**平衡算法**以及一些规则补齐了这些，规则包括
	1. ~ 非叶子节点只能允许最多两个子节点存在，就是说，分叉最多分俩，但是最下面的叶子节点除外
	2. ~ 左小右大，值是根据 hash 算法算出来的
	3. & 平衡算法，这个不太清楚，但是这个保证了树左右的高度差不超过 2 层，不会左边一大堆，右边只有一层

==B 树：==
B 树看上去跟平衡二叉树没什么大区别，但是他有几个比较大的不同
1. 他不限制子节点数一定为 2，
	1. ~ 子节点数：非叶节点（根节点和枝节点）的子节点数 >1、且子节点数量<=M 、且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
2. 他的所有叶子节点均在一层
3. 关键字的设定，关键字就是一个节点里面存的那个值，一个结点中包含多个关键字（如n个关键字），那么它就对应有n+1个孩子结点
4. @ 他的优势在于相对平衡二叉树在节点空间的利用率上进行改进，B 树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能
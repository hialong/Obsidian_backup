---
Created: 2024-01-17
Updated: 2024-01-17
Type: knowledge
Status: 🌱 完成
截止日期: 
目标: 
领域: 
Tags:
---
>缓存和数据库是两个存储数据的地方，那就可能出现缓存中的数据和实际库里面的数据对不上的情况，那我们应该怎么保证他们的一致性呢，以 mysql、Redis、和最常用的 [[Redis缓存基础#Cache Aside|Cache Aside]] 为例
>


## 缓存和数据库不一致的问题
[先删除缓存还是更新数据库后再删除缓存](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98)

是由于线程并发引起的，
对于Cache Aside 来说，先更新数据库，然后删缓存，可能会有A线程读取完数据库后再将数据写入缓存的过程中，出现了一个写操作的线程，他更新完数据库并删除完了缓存之后，线程A才将查到的旧数据写入缓存，就会出现不一致的现象
但是这个**几乎不可能出现**，因为缓存的写入比数据库写入快的多，A写回数据的时间远远小于B先写数据库，然后删除缓存的时间
![image.png](https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240107231137.png)

### 时序性问题

举个例子，比如在多线程的环境，
	Thread 1 更新 mysql 为 5->thread 2 更新 mysql 为 3->  （但是这个时候，因为时间片的原因，两个线程更新缓存的顺序反过来了） thread 2 更新缓存为 3 ->thread 1 更新缓存为 5，最终正确的数据因为时序性被覆盖了。 ^0c7604


## 如何保证数据库一致性


### 只更新数据库，不管 Redis

使用 redis 的过期期间, mysql 更新的时候，redis 不做任何处理，等缓存时间过期自动失效，然后再从 mysql 拉取缓存

#### 优缺点

优点
	1. 开发成本低，Redis 原生接口，好实现
	2. 管理成本低，出问题概率小

缺点
	比较依赖过期时间的设置，过期时间设置太长容易导致数据对不上，太短又容易出现数据库压力，需要对业务有强力的判断

### 更新 Mysql 之后，操作 Redis

这个就是旁路缓存 [[Redis缓存基础#Cache Aside]] 的写了（[[Redis缓存基础#^67a07b|Cache Aside的写流程]]），如果是新增，那就直接插入数据库后写入 redis 缓存，如果是更新，那就更新数据库后==尝试==删除对应的缓存

优点在于
	1. 能更好的保证一致性
	2. 实现成本更低

缺点
	硬要说缺点就是，可能会带来性能上的一些损耗，以及如果删除失败，那就相当于方向一[[#只更新数据库，不管 Redis]]

### 同步更新 Mysql 和 Redis

这种就是我们的 [[Redis缓存基础#Write Through]] 模式用的方式了
详细的来说就是
	把我们搭建的消费服务作为 mysql 的一个 slave，订阅 mysql 的 binlog 日志，解析日志内容，再更新到 redis。此方案和业务完全解耦，redis 的更新对业务方透明，可以减少心智成本。

优点
	- 和业务完全解耦，在更新 mysql 时候，不用额外操作
	- 无时序性问题，可靠性强


缺点
	- 引入了消息队列这种比较重的组件，还需要单独搭建一个同步服务，维护需要成本
	- 同步服务不能崩，一崩那 redis 会在很长时间里面都是旧数据

